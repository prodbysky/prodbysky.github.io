<!DOCTYPE html>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bong</title>
    <link rel="stylesheet" href="./stylesheet.css" type="text/css" />
    <link href="https://dev.prismjs.com/themes/prism-tomorrow.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
</head>

<body>
    <h1>Bong</h1>
    <p>
        <a href="https://github.com/prodbysky/bong">Github repository</a>
        <br>
        <a href="#Day 1">Skip my rambling</a>
    </p>
    <h2>Motivation</h2>
    <p>
        Essentially I'm annoyed at many languages (I hate them all equally).
        <br>
        C is really damn good for an old language but having to write an additional
        standard library on top of libc gets annoying really quick.
        <br>
        Rust is a good modern language however interacting with C code manually is pretty bad.
        The borrow checker, in my opinion, is not a good solution to memory safety.
        <br>
        C++ needs a LOT of linters/rules to be a readable and maintainable language, and it is really ugly
        <br>
        Odin is really cool, one of my favourites right now, but the `go` way of handling errors, where you don't have
        to check for errors is bad. Again in my opinion.
        <br>
        Zig is really annoying with all the "control" you get on the code, uses LLVM (applies to Rust), which makes
        the compilation times really slow
        <br>
        So that's why I want to make my own language. No LLVM, and just my personal preferences in a language.
        I'm going to write it in C, since using a barebones language makes it easier to self-host the language and
        that's it.
    </p>
    <h2 id="Day 1">Day 1 - Some book keeping </h2>
    <a href="https://github.com/prodbysky/bong/commit/8252f3beb656010e22d61c4ee88639319973cf08">Commits covered</a>
    <p>
        Before any development can begin, we need to decide on the build system to use.
        <br>
        As for the build system, I'm really drawn to Tsodings <a href="https://github.com/tsoding/nob.h">nob.h</a>
        It's really simple (being a single header file), really extensible, cross-platform, and is just a pleasure to
        use.
        So I'm just going to go with it.
        <br>
        To build our current project (single main.c) file we just do this in nob.c (our build script):
    <pre>
        <code class="language-clike">
// This is an stb style library therefore this #define includes the implementations of the library
#define NOB_IMPLEMENTATION
#define NOB_STRIP_PREFIX
#include "nob.h"

// We have to take the arguments so that the build system can recompile itself when we change it
int main(int argc, char** argv) {
    NOB_GO_REBUILD_URSELF(argc, argv);
    Cmd c = {0};
    mkdir_if_not_exists("build");
    cmd_append(&c, "cc", "src/main.c", "-o", "build/bongc", "-Wall", "-Wextra");
    if (!cmd_run_sync_and_reset(&c)) return false;
}
        </code>
    </pre>
        NOTE: I will not document all changes to this script to see them you can go to <a href="https://github.com/prodbysky/bong/blob/master/nob.c">here</a><br>
    Yes. That's it just build nob.c to an executable and run it. When the source (nob.c) is changed it will
    automatically rebuild and run the new version of the script.
    No "configuration" step. Just build and run.
    <br>
    We will need dynamic memory allocations therefore, we
    will have to implement an <a href="https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator">arena
        allocator</a>.
    Why do I want to have arenas?
    <ol>
        <li> It makes lifetime management easier, you can make lots of tiny allocations, and keep that region in cache
            (since you will hit it so many times). </li>
        <li> Freeing trees (such as ASTs) is way easier since you don't have to do a recursive traversal</li>
    </ol>
    The entire interface to an arena is this:
    <pre>
        <code class="language-clike">
typedef struct {
    uint8_t* buffer;
    size_t capacity;
    size_t used;
} Arena;

Arena arena_new(size_t size) {
    Arena a = {0};
    a.capacity = size;
    a.buffer = calloc(size, sizeof(uint8_t));
    assert(a.buffer && "Ran out of RAM?");
    return a;
}

void* arena_alloc(Arena* a, size_t size) {
    assert(a->buffer);
    assert(a->used + size < a->capacity);
    void* buf = a->buffer + a->used;
    a->used += size;
    return buf;
}

void arena_free(Arena* a) {
    assert(a->buffer);
    free(a->buffer);
    memset(a, 0, sizeof(Arena));
}
        </code>
    </pre>
    I just do assertions instead of error handling since if we can out of memory, what can we do?
    <br>
    It's getting late. So this is all I did in day 1, holy productivity...
    </p>
    <h2 id="Day 2">Day 2 - Take a look at some tokens</h2>
    <a href="https://github.com/prodbysky/bong/commit/8252f3beb656010e22d61c4ee88639319973cf08">Commits covered</a>
    <p>
        Before we can extract the tokens, we have to read the file into memory.
        Since nob requires some hoops to jump through to use a custom allocator and I don't want to make
        our allocator global (to be more explicit). I'll implement the famous da_append(...) macro, and accept an arena.
        Also the String, and StringView primitives to make strings easier in C. To explain them, they are just non-null terminated strings,
        String is an owned string (like Rusts String) and String_View is a view (&str), it's immutable.
        To ease reporting errors in the future I'll also define a struct for a source file (String of the source contents, and a name of the file)
        <br>
        When it comes to lexing/tokenizing source code, the most common way to represent the results
        of this process, is a <a href = "https://en.wikipedia.org/wiki/Tagged_union">tagged union</a>.
        <br>
        Because I just want to layout the structure of the lexer, I'm going to implement a single token kind - an unsigned integer.
    <pre>
        <code class="language-clike">
typedef enum {
    TT_NUMBER
} TokenType;

typedef struct {
    TokenType type;
    size_t offset;
    union {
        uint64_t number;
    };
} Token;
        </code>
    </pre>
        Ok so after some bickering with C, we have our own specified da_push generic macro for dynamic arrays.
        Time to actually lex code.
        This is our lexer state
    <pre>
        <code>
typedef struct {
    SourceFile const* source;
    size_t pos;
} Lexer;
        </code>
    </pre>
    The `SourceFile` keeps track of the actual content and name of the file that we are processing.
    <br>
    Since our current task is so simple we can just skip whitespace (since that is insignificant, looking at python...)
    This logic is described in this
        <a href="https://github.com/prodbysky/bong/blob/8252f3beb656010e22d61c4ee88639319973cf08/src/main.c#L103C1-L103C44">code snippet</a>
    And just do the lexing, which can be viewed in the repo now :)
    <h2 id="Day 3">Day 3 - Expressions and operators</h2>
    Ok first I just implemented a printer which is not that complicated (<a href = "https://github.com/prodbysky/bong/blob/6e2453e27b7a162872fb353d1ae34d77459468e3/src/main.c#L110">Source</a>)
    <br>
    And now we need operators, of which I'll just go with `+` and `-`. Since they are single characters lexing them is really easy (<a href="https://github.com/prodbysky/bong/blob/f47063e72e3052d379b791c2155b1703c2dbf4ff/src/main.c#L140">Source</a>).
    <br>
    I hope you appreaciate my web dev skillz (surely)
    <br>
    Time for a parser (weeeeeeeeeeeeeeee).
    This is the part I hate just because operator precedence feels like magic, even though I understand that. 
    We essentially just put the operators with "higher binding power" lower in the tree.
    The helping hand is the <a href="https://craftinginterpreters.com/">Crafting interpreters</a> book by Robert Nystrom, if you want to build a language that book is a MUST have.
    The book is paid so I don't know the legality of providing a snippet of the <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a>, however such BNF can be derived by hand (which I did in my prior projects when I didn't know about the previously mentioned book.
    What I forgot about the lexer is that we need to report errors. I was already keeping track of the bbyte offset of the token within the file, but I wasn't tracking the length and the origin of the token, so I need to fix that up that up real quick.
    <br>
        Ok so C was a bit more of a beast than I expected however I pulled <a href="https://github.com/prodbysky/bong/commit/54d38aaa16bbaa0113212d490e77c64262ff2951">through</a>
    </p>
</body>

</html>
