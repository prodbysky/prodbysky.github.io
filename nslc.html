<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hello!</title>
    <link rel="stylesheet" href="./stylesheet.css" type="text/css" />
  </head>
  <body>
        <h1>nslc</h1>
        <p>
            This is a dev-log of my own programming language nslc,
            that I'm making purely for fun (so far).
            I have decided to start this whole github pages thing, just
            because I want to have a visual way of viewing progress
            The repo is available here: <a href="https://github.com/prodbysky/nslc">prodbysky/nslc</a>
            <br>
            <a href="#epilogue">Epilogue</a>
            <br>
            <a href="#day1">Day 1</a>
            <br>
            <a href="#day2">Day 2</a>
            <br>
        </p>
        <h2 id="epilogue">Epilogue</h2>
        <p>
            Why am I doing this? Well for fun of course ;-;
            I began this project by sketching out the pipeline from source code to executable
            input.nsl -> tokenizer (lexer) -> ast parser -> type checker -> dead code analysis -> qbe -> executable
            So yes I will be using <a>qbe</a> as the compiler backend of choice, since this is my first try at a language
            Well not really, but the first serious no going back type of try
            I have already decided beforehand that I won't use any parser generators (yacc, ...) since I want full control other the language
            And yes before going on with the details, I tried to implement a language in Rust in the same name,
            However I just felt that something was off so I switched lanes to C
        </p>
        <h2 id="day1">Day #1</h2>
        <p>
            Because I'm writing this after the work is done, it's going to be a short summary
            So we now have:
            A basic lexer that doesn't even report errors correctly
            An AST parser that uses a different way of parsing binary expressions than what I'm used to
            Instead of encoding the precedence of operators via recursion I decided to use a way
            I can't really describe
            A really basic QBE code generation library, that will grow as this language evolves
            Since so far it can only really add, subtract, divide and multiply numbers known
            at compile time, and return the result
            And a basic code generation module that uses the before mentioned QBE wrapper
            
        </p>
        <h3>Notes</h3>
        <p>
            <code>-fsanitize=address, -Wextra, -Wall </code> are my best buddies from now on.
            <a>Nob</a> as a build system is soooooo DAMN GOOD.
            Editing html from neovim is a pain for me.
        </p>
        <h2 id="day2">Day #2</h2>
        <p>
            Woke up too early this morning, and found out my dad blocked my pc AND phone from the wifi
            Anyways I worked on slightly better error reporting. I've decided to use line and column numbers
            Did some minor things to make the code more readable
            Next variables? I think it's approapriate ( I don't know how to spell that :d )
            You thought. Tried to document some code instead found some serious bug that I'll debug later today.
            ...
            After a while of pondering, I found it:
        </p>
            
        <pre>
<code>
loop {
    Statement s = parser_statement(&parser);
    if (s.type == ST_ERROR) {
        fprintf(stderr, "Failed to parse file due to invalid statement\n");
        arrfree(parser.statements);
        parser.statements = NULL;
        return parser;
    }
    arrput(parser.statements, parser_statement(&parser));
}
</code>
        </pre>
            
        <p>
            Yes so the whole time I was just calling the function that advanced the ast parser
            Stupid.
            Wow what a productive day :)
            I mean it's cool school is being like a clingy gf in my life
        </p>
  </body>
</html>
